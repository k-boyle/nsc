#+STARTUP: showall
#+TITLE: Function Inference

* Motivation
  Function inference allows for a function to have multiple overloads for the 
  same parameters types, but return values of different types depending on the context in which the 
  function was used.
  Function inference forms an integral part of NoSyn's extention framework, allowing the user of the language
  to create a DSL or general purpose language within NoSyn with great capability to customize it's syntax.

** Usage Example
Consider the following expression:
#+BEGIN_SRC c++
2:6
#+END_SRC

The user may with wish this to mean concatenating the two numbers into a list of integers.
But there are also languages in which this symbol is used to denote to the start and the end of an 
array slice:
#+BEGIN_SRC go
//GO CODE
a[2:6]
#+END_SRC

NoSyn provides the user with the ability to overload all operators, infact by default no operators are defined.
Assuming that an overload function has been created for the square brackets on an array to perform array access,
the user could set up the language as follows:
#+BEGIN_SRC c++
//NO SYN code
[T] operator_:_<T>(T a, T b) {
  native_formArray(a,b)
}
[T] operator_:_<T>(T x, [T] xs) {
  native_formArray(x,xs)
}

T operator_[]_<T>([T] array, Int index) {
  native_indexAccess(array, index)
}
[T] operator_[]_<T>([T] array, [Int] index) {
  native_sliceArray(array, index)
}

[Int] slicedArray = a[2:6] //Assuming 'a' is an Integer array.
#+END_SRC

This system will work providing the user with the capability to use the colon symbol as both an array contatentation operator
as well as an array slice operator.
But this way comes with a serious flaw:
#+BEGIN_SRC c++
[Int] slicedArray = a[2:4:5:6]
#+END_SRC

This should be considered a syntax error. But it's not. 
As the operator overload for [] is expecting to see an 
array, =2:4:5:6= is a perfectly plausible expression to put inside the square brackets.
Of course the error could be picked up in the =native_sliceArray= expression but this would mean that 
the check would only be made at runtime.
This is where function inference can become very useful.

*** Function Inference Example
#+BEGIN_SRC c++
//NO SYN code
[T] operator_:_<T>(T a, T b) {
  native_formArray(a,b)
}
(Int, Int) operator_:_(Int l, Int r) {
  (l,r)
}
[T] operator_:_<T>(T x, [T] xs) {
  native_formArray(x,xs)
}

T operator_[]_<T>([T] array, Int index) {
  native_indexAccess(array, index)
}
[T] operator_[]_<T>([T] array,  (Int, Int) arraySlicer) {
  native_sliceArray(array, index)
}

[Int] slicedArray = a[2:6] //Assuming 'a' is an Integer array.
#+END_SRC

This new implementation allows for both element concatenation and array slicing while maintaining the ability to throw an
error at compile time when =a[1:2:3]= is provided.
This code still has a problem however. The operator overload that has been created returns a tuple of two ints.
This is not ideal as the syntax that was specifically designed for generating an array slice would also be used in other contexts:
#+BEGIN_SRC c++
(Int, Int) vector = 20:30 //Unwanted ability to create regular tuples
[Int] slicedArray = a[(2,6)] //Unwanted ability to use tuples within the array access
#+END_SRC

In order to prevent this usage of the colon operator, a closed alias can be used:
#+BEGIN_SRC c++
alias closed ArraySlicer = (Int, Int)

ArraySlicer operator_:_(Int a, Int b) {
  (l,r)
}

operator_[]_<T>([T] array, ArraySlicer arraySlicer)_{
  native_sliceArray(array, arraySlicer)
}
#+END_SRC

Using this implementation. The colon operator overload function will only be infered if the context in which it is used is specifically 
of the type =ArraySlicer= and not simply =(Int, Int)=.

* Algorithm for Function Inference
   
Function inference uses a type inference algorithm to work out which function overload to use. Where as type inference is often used to save the programmer time by
not requiring the user to specify what the type of a variable or function is, function inference expects a certain amount of information about the context it is being
used in. As such, *No Syn* does not allow the user to specify a variable without also specifying the type of that variable. Functions similarly must indicate what the return type
is, although template types are still valid.
This constraint employed in using function inference is used to reduce the ambiguity which can arise using such a type system. Later I will explore ways in which type inference of variables
may be possible alongside function inference, and why such a feature may not be wanted.

** Context Deduction
Function inference works on the basis of deducing the context in which a function is being used. 
All function calls are expressions and can be built up into larger expressions.
+ All expressions have a single type
+ Expressions can be used as a statement if they have the type =Nothing=
+ literals have a clear concrete type
Using these rules we can deduce that given the following statement:
#+BEGIN_SRC c++
foo(10)
#+END_SRC
+ The type of the expression =foo(10)= must be =Nothing= as it is being used as a statement
+ The function overload of =foo= is =Int->Nothing= as the literal =10= has the concrete type of =Int=
